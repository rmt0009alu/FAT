\apendice{Documentación técnica de programación}

\section{Introducción}

En este anexo se recoge la documentación técnica de programación, que incluye recomendaciones para el entorno de desarrollo, la estructura de directorios, los procesos de compilación, la configuración de integración e instalación de dependencias y las baterías de tests realizadas. 

\section{Estructura de directorios}

El repositorio del proyecto tiene la siguiente distribución de directorios:

\begin{itemize}
\tightlist
\item
\texttt{/}: directorio raíz. Además de todas las rutas de aplicaciones y utilidades, que se detallan a continuación, hay una serie de archivos que cumplen las siguientes funciones:
	\begin{itemize}
	\tightlist
	\item
	\texttt{manage.py}: archivo de utilidad de línea de comandos para tareas 
	administrativas de \emph{Django}.
	\item
	\texttt{.gitignore}: configuración de los archivos que no se encuentran en el 
	repositorio de \emph{GitHub}. Queda a criterio del desarrollador modificar este archivo 
	según las necesidades. 
	\item
	\texttt{.pylintrc}: archivo con configuración general de la herramienta de medición de calidad de código \texttt{pylint}.
	\texttt{README.md}: archivo con recomendaciones de instalación y licencia para mostrar en la portada del repositorio de \emph{GitHub}.
	\texttt{requirements.txt}: dependencias del proyecto. 
	\end{itemize}

\item 
\texttt{/.github}: archivos de configuración de \emph{GitHub actions}.

\item 
\texttt{/Analysis}: archivos de la \emph{app Analysis}. Entre otros, aquí se pueden ver los modelos \emph{StockBase}, \emph{Sectores} y \emph{CambioMoneda}.

\item 
\texttt{/Analysis/migrations}: archivos, con migraciones de modelos a bases de datos, generados automáticamente por \emph{Django}.

\item 
\texttt{/Analysis/templates}: plantillas HTML que permiten ver múltiple información de un valor y su sector asociado.  

\item 
\texttt{/Analysis/templates/includes}: plantillas HTML auxiliares que aportan mejor organización al proyecto. Todas las plantillas tienen nombres con referencias a las funciones que cumplen para mejorar la mantenibilidad.

\item 
\texttt{/DashBoard}: archivos de la \emph{app} que gestiona el área de usuario, donde se puede realizar, por ejemplo, el control de una cartera y ver la distribución de pesos más adecuada. 

\item 
\texttt{/DashBoard/migrations}: archivos, con migraciones de modelos a bases de datos, generados automáticamente por \emph{Django}.

\item 
\texttt{/DashBoard/templates}: plantillas HTML que permiten ver información agregada sobre la cartera del usuario. También están disponibles los formularios de interacción con el usuario para las funcionalidades de esta \emph{app}.

\item 
\texttt{/DashBoard/templates/includes}: plantillas HTML auxiliares.

\item 
\texttt{/databases}: directorio en el que se encuentran las bases de datos de la aplicación. 

\item 
\texttt{/docs}: carpeta de documentación. 

\item 
\texttt{/docs/burndowns}: donde se almacenan las imágenes que corresponden a la evolución de los diferentes \emph{sprints}.

\item 
\texttt{/docs/latex}: documentación de la memoria y los anexos del Trabajo de Fin de Grado que ha llevado al desarrollo de este proyecto. 

\item 
\texttt{/docs/sphinx/\_build/html}: documentación en formato HTML de todo el código del proyecto siguiendo el estilo de \emph{ReadTheDocs}.

\item 
\texttt{/FAT}: aplicación principal para gestión del proyecto. Aquí se encuentra el archivo de \texttt{settings.py} junto con otros archivos relevantes para el correcto funcionamiento del resto de aplicaciones. También se puede ver la configuración del enrutamiento a las bases de datos. Además, aquí se encuentra el archivo \texttt{.env} donde se guardan las claves secretas de \emph{Django} y \emph{NewsAPI}.

\item 
\texttt{/htmlcov}: informe de tests realizado con \texttt{coverage}.

\item 
\texttt{/Lab}: archivos de la \emph{app} que gestiona el laboratorio virtual. Aquí se encuentran los archivos de control de modelos ARIMA, estrategias basadas en \emph{machine learning}, etc. 

\item 
\texttt{/Lab/migrations}: directorio vacío porque esta \emph{app} utiliza modelos ya creados para otras aplicaciones del mismo proyecto; se crea automáticamente por \emph{Django}. Aquí podemos ver los formularios \emph{Django} que se utilizan para interactuar con el usuario. 

\item 
\texttt{/Lab/templates}: plantillas HTML que permiten ver información y mostrar con los formularios con los campos predefinidos en \texttt{forms.py}.

\item 
\texttt{/Lab/templates/includes}: plantillas HTML auxiliares.

\item 
\texttt{/log}: configuración del \emph{logger} y archivos de \emph{log} de los tests realizados. Estos archivos pueden ser útiles para futuros desarrolladores.

\item 
\texttt{/News}: archivos de la \emph{app} que gestiona las noticias y la información de valores de la portada web. 

\item 
\texttt{/News/migrations}: directorio vacío, igual que en \texttt{/Lab/migrations}.

\item 
\texttt{/News/templates}: plantillas HTML que permiten ver información de portada. 

\item 
\texttt{/News/templates/includes}: diseño de botones HTML de utilidad. 

\item 
\texttt{/static}: archivos estáticos. 


\item 
\texttt{/static/admin}: archivos de \emph{Django} que permiten el acceso, a través de \texttt{http://127.0.0.1:8000/admin/}, al área de gestión visual de administración.

\item 
\texttt{/static/css}: archivos CSS utilizados en el proyecto para mantener los mismos estilos en las diferentes aplicaciones. 

\item 
\texttt{/static/icons}: diferentes iconos para mostrar en la herramienta. 


\item 
\texttt{/tests}: todos los tests de las distintas aplicaciones y pruebas de algunas de las herramientas de utilidad creadas para favorecer el desarrollo. 

\item 
\texttt{/util}: herramientas de utilidad para controlar los índices bursátiles y valores disponibles. Además, aquí se almacenan las referencias de los \emph{feed} RSS y los archivos que sirven para crear y/o actualizar las bases de datos. 
\end{itemize}


\section{Manual del programador}

En este manual se explican los pasos más relevantes que se han seguido para la creación de este proyecto y que pueden servir como referencia para futuros desarrolladores. En él se explica cómo preparar el entorno de desarrollo y qué dependencias necesitaremos. Además, se detallan los pasos más relevantes en cuanto a compilación, instalación y ejecución.

Se recomienda consultar la \href{https://fat.readthedocs.io/es/latest/intro.html#}{documentación} y, especialmente, el apartado de \emph{Instalación en local}, donde se encuentra disponible un resumen de este manual. El mismo resumen se puede encontrar en la portada del \href{https://github.com/rmt0009alu/FAT}{repositorio de este proyecto}. 

A continuación se detallan los pasos lógicos que se pueden seguir para trabajar con este proyecto:



\textbf{Paso 1. Descargar, clonar o hacer un \emph{fork} del repositorio}

Podemos descargar los archivos desde el \href{https://github.com/rmt0009alu/FAT}{repositorio}. 

\imagen{img_anex_23.png}{Descargar proyecto en formato .zip}{1}

Si tenemos instalado un sistema de control de versiones distribuido como \href{https://git-scm.com/downloads}{Git}, podremos hacer un \emph{clon} del repositorio para trabajar con él en local. Este método es ideal si no se pretenden hacer contribuciones con el proyecto original. Sólo debemos crear un directorio donde queramos instalar los archivos del repositorio y lanzar el siguiente comando:

\imagen{img_anex_24.png}{Clonar con \emph{Git} .zip}{0.8}

Otra opción es que se haga un \emph{fork} para guardar los datos en un repositorio del desarrollador. De esta manera se podrá contribuir fácilmente con el desarrollo realizado hasta ahora. 



\textbf{Paso 2. Intalar Python}

Una vez tenemos los archivos en nuestro equipo tendremos que instalar \href{https://www.python.org/downloads/}{Python}. En el desarrollo de este proyecto se ha utilizado Python 3.11.5. 



\textbf{Paso 3. Instalar entorno}

Instalar un IDE del gusto del desarrollador. Se recomienda el uso de \href{https://code.visualstudio.com/download}{VS Code}.

\emph{VS Code} ya se puede considerar un entorno de desarrollo integrado. Aunque inicialmente fue concebido como un editor de código fuente ligero, ha evolucionado para ofrecer muchas de las funcionalidades que se esperan de un IDE; y en el desarrollo de este proyecto no han sido necesarias más herramientas. 

\imagen{img_anex_25.png}{VS Code}{1}



\textbf{Paso 4. Abrir directorio del respositorio}

Abrir la ruta donde están los archivos del repositorio desde VS Code (o el editor/entorno deseado).



\textbf{Paso 5. Entorno virtual}

Es altamente recomendable trabajar con un entorno virtual. Su instalación es sencilla y puede ayudarnos a controlar mejor las dependencias necesarias.

Pulsamos \texttt{F1} y podemos escribir \emph{Interpreter} para seleccionar el \emph{interpreter} de \emph{Python} que se adapte a las características del proyecto: 

\imagen{img_anex_26.png}{Selección de \emph{interpreter}}{1}

Luego volvemos a pulsar \texttt{F1} y escribimos \texttt{Terminal} para abrir una nueva terminal. Desde esa terminal creamos nuestro entorno virtual, en el mismo directorio en el que tengamos los archivos del repositorio:

\begin{verbatim}
  > python -m venv venv
\end{verbatim}



\textbf{Paso 6. Instalar las dependencias en el entorno virtual}

En este proyecto se puede encontrar un archivo \emph{requirements.txt} con todas las dependencias. Pero para facilitar la instalación se recomienda seguir los siguientes pasos, ya que se instalarán las librerías en el orden adecuado y todas las dependencias de terceros estarán disponibles igualmente:

Primero abrimos el entorno virtual que hemos creado en el paso previo:

\begin{verbatim}
  > .\venv\Scripts\activate
\end{verbatim}

Veremos algo similar a lo siguiente: 

\imagen{img_anex_27.png}{Activar entorno virtual}{0.8}

\newpage

Luego se instalan, en ese entorno virtual, el \emph{framework}, las librerías y las APIs necesarias:

\begin{verbatim}
  (venv) > python -m pip install Django
  (venv) > python -m pip install pandas
  (venv) > python -m pip install plotly==5.18.0
  (venv) > python -m pip install newsapi-python
  (venv) > python -m pip install -U matplotlib
  (venv) > python -m pip install mpld3
  (venv) > python -m pip install django-pandas
  (venv) > python -m pip install feedparser
  (venv) > python -m pip install yfinance
  (venv) > python -m pip install python-dotenv
  (venv) > python -m pip install networkx
  (venv) > python -m pip install statsmodels
  (venv) > python -m pip install scikit-learn
  (venv) > python -m pip install pmdarima
  (venv) > python -m pip install tensorflow
\end{verbatim}

\textbf{Paso 7. Configurar claves secretas}

Este proyecto requiere dos claves secretas que no están disponibles, pero que se pueden conseguir de manera sencilla.

Aquí se explica cómo conseguirlas y añadirlas al entorno del usuario:

\begin{itemize}

\item
\textbf{Paso 7.1. SECRET\_KEY de Django}
Generar una \texttt{SECRET\_KEY} de \emph{Django} de manera aleatoria desde una terminal en el entorno virtual:

\begin{verbatim}
  (venv) > python -c 'from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())'`
\end{verbatim}


   Guardar la clave en \texttt{/FAT/.env.example}, sin usar comillas, nos deberá quedar un archivo con el siguiente texto:

\begin{verbatim}
  export SECRET_KEY=clave_larga_123456_clave_larga
\end{verbatim}

\item
\textbf{Paso 7.2. Clave de API NewsAPI}

Acceder a \href{https://newsapi.org/}{NewsAPI} y solicitar una clave de acceso con un registro.

   Guardar la clave en \texttt{/FAT/.env.example} - sin usar comillas - nos deberá quedar un archivo con el siguiente texto:
   
\begin{verbatim}
  export SECRET_KEY=clave_larga_123456_clave_larga
  export NEWS_API_KEY=clave_api_123456_clave_api
\end{verbatim}

\item
\textbf{Paso 7.3. Cambiar el nombre de .env.example}
Cambiar el nombre de \texttt{/FAT/.env.example} por \texttt{/FAT/.env}.

\end{itemize}



\textbf{Paso 8. Lanzar el servidor}

Como ya tenemos configurado el entorno, sólo queda empezar a utilizarlo:

\begin{verbatim}
  (venv) > python .\manage.py runserver
\end{verbatim}

  Hacer click en la ruta local que aparece, normalmente \href{http://127.0.0.1:8000/}{localhost}.

\imagen{img_anex_28.png}{Lanzar el servidor}{0.8}


\newpage
\textbf{Paso 9. ¿Quieres actualizar las bases de datos?}

Es posible actualizar las bases de datos de los índices bursátiles y sus valores cotizados, para tener información con precios de cierre de la última sesión disponible.

Es \textbf{importante} que antes de actualizar compruebes que el servidor no está activo.

Puedes lanzar el \emph{script} \texttt{ActualizarBDs.py}, una vez realizada la comprobación previa, desde la ruta principal del proyecto:

\begin{verbatim}
  (venv) > python .\util\ActualizarBDs.py
\end{verbatim}

Este \emph{script} permite actualizar las bases de datos \texttt{dj30}, \texttt{ibex35}, \texttt{ftse100} y \texttt{dax40} con precios de cierre. \textbf{Para que se obtengan precios de cierre es necesario actualizar fuera de horarios de cotización}. Es decir, necesitamos que los mercados estén cerrados y, por ello, en el \emph{script} \texttt{ActualizarBDs.py} se ha configurado un rango de horas permitidas. Esto está pensado para trabajar en un servidor remoto que lanza el \emph{script} de forma automática (con \emph{cron}, por ejemplo), pero si se quieren modificar las horas, sólo es cuestión de cambiar los horarios en el método \texttt{\_permite\_actualizar(logger)}.

Se recomienda hacer actualizaciones en fines de semana o en horarios en los que tanto mercados estadounidenses como europeos estén cerrados.



\textbf{Paso 10. ¿Quieres crear las bases de datos desde cero?}

Es posible eliminar las bases de datos actuales y crearlas desde cero si se desea, por ejemplo, limpiar toda la información de la base de datos por defecto o si se quiere ampliar la cantidad de datos históricos de los índices bursátiles.

Para realizar esta operación hay que eliminar las migraciones previas:

\begin{verbatim}
  (venv) > python .\manage.py migrate Analysis zero
  (venv) > python .\manage.py migrate DashBoard zero
\end{verbatim}

Además de los comandos anteriores es altamente recomendable eliminar los archivos \texttt{/Analysis/migrations/0001\_initial.py} y \\ \texttt{/DashBoard/migrations/0001\_initial.py}.

Con las migraciones eliminadas, el siguiente paso es eliminar las bases de datos del directorio \texttt{/databases}.

Posteriormente ya podremos crear las nuevas migraciones con:

\begin{verbatim}
  (venv) > python manage.py makemigrations
  (venv) > python manage.py migrate
  (venv) > python manage.py migrate --database=dj30
  (venv) > python manage.py migrate --database=ibex35
  (venv) > python manage.py migrate --database=ftse100
  (venv) > python manage.py migrate --database=dax40
\end{verbatim}

Por último, hay que lanzar el \emph{script} \texttt{CrearBDs.py}, asegurándonos, como se indica en el paso 9, de no tener el servidor activo y de que los mercados bursátiles están cerrados:

\begin{verbatim}
  (venv) > python .\util\CrearBDs.py
\end{verbatim}



\textbf{Paso 11. ¿Quieres crear un usuario administrador?}

Los usuarios administradores en \emph{Django} tienen la capacidad de gestionar información de la plataforma en un entorno visual agradable, pudiendo crear, eliminar y modificar objetos.

Lo que el administrador podrá ver depende de la configuración establecida en los archivos \texttt{admin.py} de las diferentes aplicaciones.

Para crear un \emph{admin} sólo hay que lanzar el siguiente comando:

\begin{verbatim}
  (venv) > python manage.py createsuperuser
\end{verbatim}



\textbf{Opcional. Dependencias adicionales interesantes}

\begin{itemize}

\item
Para limpiar las rutas de \texttt{\_pycache\_}:

\begin{verbatim}
  (venv) > python -m pip install pyclean
\end{verbatim}

Modo de uso:

\begin{verbatim}
  (venv) > pyclean .
\end{verbatim}

\item
Para testear el código:

\begin{verbatim}
  (venv) > python -m pip install coverage
\end{verbatim}

Modo de uso:

\begin{verbatim}
  (venv) > coverage run manage.py test tests
  (venv) > coverage html
\end{verbatim}


Consular el informe generado en \texttt{/htmlcov/index.html}.

\item
Para comprobar la calidad del código:

\begin{verbatim}
  (venv) > python -m pip install pylint
\end{verbatim}

Modos de uso:

\begin{verbatim}
  (venv) > pylint .\DashBoard\views.py
  (venv) > pylint .\DashBoard
  (venv) > pylint .
\end{verbatim}


\item
Para crear documentación del estilo de ReadTheDocs:

\begin{verbatim}
  (venv) > python -m pip install sphinx
  (venv) > python -m pip install sphinxcontrib-django
  (venv) > python -m pip install sphinx_rtd_theme
  (venv) > python -m pip install recommonmark
\end{verbatim}

Modo de uso:

\begin{verbatim}
  cd .\docs\sphinx\
  (venv) \docs\sphinx\ > .\make.bat html
\end{verbatim}

En \texttt{/docs/sphinx/\_build/html/index.html} se puede consular la documentación del código generada.

\end{itemize}


\section{Pruebas del sistema}

En este trabajo se han realizado múltiples pruebas, creando instancias \emph{adhoc} para los tests en muchos casos. Inicialmente se tomó la decisión de no utilizar \emph{mocks}, de esta manera se simulaba que se realizan pruebas de integración con las bases de datos de forma continua. Esta decisión implica que el rendimiento de los propios tests disminuye, ya que se están creando instancias reales, pero favorece el control de los datos y obliga al desarrollador a entender lo que está ocurriendo en cada momento. 

\subsection{Tests unitarios}

En este trabajo hay 250 tests unitarios, que cubren prácticamente todo el código, como se puede ver en el informe HTML realizado con \texttt{coverage} y que está disponible en \texttt{htmlcov/index.html}:

\imagen{img_anex_29.png}{Número de tests realizados}{1}

Al final del informe de \texttt{coverage} podremos ver el siguiente resultado: 


\tablaSmall{Cobertura de código}
{c|c|c|c|c}
{tabla_coverage}
{
\rowcolor{gray!35}
\textbf{Module} & \textbf{statements} & \textbf{missing} & \textbf{excluded} & \textbf{coverage} \\
}
{
Total & 4122 & 11 & 0 & 100\% \\
}

Con estos tests se han realizado:

\begin{itemize}
\item
Pruebas de caja blanca, que implican el conocimiento del código:
\begin{itemize}
\item 
Pruebas de interfaces entre modelos y métodos.
\item
Pruebas de estructuras de datos locales. 
\item
Pruebas de camino básico (en algunos casos).
\item
Pruebas de condiciones límite, especialmente para el control de entrada de datos de usuarios, tanto en \emph{login} y registro como para trabajar con las aplicaciones \emph{DashBoard} y \emph{Lab}. 
\end{itemize}

\item
Pruebas de caja negra, como si no se conocieran los datos:

De forma intensiva se han probado todos los contextos con los datos a renderizar en cada plantilla, sin tener en cuenta el código interno.

En estas pruebas se incluyen los siguientes conceptos:

\begin{itemize}
\item 
Partición de equivalencia: se ha tratado de dividir la entrada en aplicaciones y cada aplicación en vistas, formularios, etc. 
\item
Análisis de valores límite. 
\end{itemize}
\end{itemize}

Además, se puede comprobar un \emph{log}, que fui realizando para un mejor control y que guarda un comentario de casi todas aquellas pruebas que se van pasando. La estructura del \emph{log} se controla con un \emph{logger} y se pueden comprobar estos datos en el directorio \textbf{/log}.



\subsection{Pruebas de integración}

Como se ha mencionado en el apartado anterior, se ha tratado de comprobar continuamente la correcta integración con las bases de datos. Pero, de forma adicional, en las fases iniciales del proyecto se realizó una batería básica de tests para comprobar la correcta creación y actualización de las bases de datos, así como el enrutamiento y la configuración general del proyecto.

Estos tests están disponibles en \texttt{/tests/databases} y en \texttt{/tests/FAT}.  

Su ejecución se realiza a través de \texttt{coverage} tal y como se indica en el apartado anterior. 


\subsection{Pruebas de interfaz}

Se han realizado algunas pruebas básicas de interfaz utilizando la librería \emph{selenium}\citep{online:selenium} y el \emph{driver} de \emph{Chrome}. Estos tests se pueden encontrar en el archivo \texttt{tests/tests\_ui/tests\_ui.py} junto con el \emph{chromedriver.exe}\citep{online:chrome_driver} para el navegador web Chrome versión 125.0.xxxx. 

Con estas pruebas se trató de simular interacciones con usuarios, especialmente para funcionalidades de registro, \emph{login} y \emph{logout}. También se probó la interacción con algunos formularios de la web - no todos -. 

La batería de pruebas de interfaz es reducida, ya que las diferentes casuísticas estaban recogidas en los tests unitarios, pero han cubierto los siguientes requerimientos:


\begin{table}[H]
\centering
\begin{tabularx}{\textwidth}{>{\ttfamily}lX}
\toprule
\textnormal{Test} & Requerimiento \\
\midrule
test\_pag\_principal & RF-1 Mostrar portada con información general. \\
test\_pag\_principal\_artículos & RF-1.1 Mostrar carrusel de noticias generales. \\
test\_pag\_principal\_mejores\_peores & RF-1.2 Mostrar mejores y peores valores de cada índice. \\
test\_login & RF-2 Control de usuarios. RF-2.2 Permitir hacer login. \\
test\_logout & RF-2 Control de usuarios. RF-2.2 Permitir hacer logout. \\
test\_registro & RF-2 Control de usuarios. RF-2.2 Permitir hacer registro. \\
test\_mostrar\_tabla\_valores & RF-4 Consultar índice. RF-4.1 Mostrar tabla de valores. \\
test\_consultar\_un\_valor & RF-4 Consultar índice. RF-4.2 Consultar un valor del índice. \\
test\_dashboard\_nueva\_compra & RF-3 Gestionar DashBoard. RF-3.1 Crear nuevo valor en cartera. \\
test\_dashboard\_nuevo\_seguimiento & RF-3 Gestionar DashBoard. RF-3.3 Crear un nuevo valor en seguimiento. \\
test\_arima\_manual & RF-5.1 Trabajar con ARIMA. RF-5.1.2 Introducir (p,d,q) de forma manual. \\
\bottomrule
\end{tabularx}
\caption{Requerimientos testeados con pruebas de interfaz.}
\label{requisitos-test}
\end{table}

\newpage
Para lanzar estas pruebas se realiza lo siguiente:

\imagen{img_anex_30.png}{Lanzar pruebas de interfaz}{1}

Y el resultado esperado es:

\imagen{img_anex_31.png}{Resultado de pruebas de interfaz}{1}