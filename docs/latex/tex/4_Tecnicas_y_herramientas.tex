\capitulo{4}{Técnicas y herramientas}

\section{Técnicas metodológicas}\label{metodologias}

\subsection{Scrum}\label{scrum}

\emph{Scrum} \citep{wiki:Scrum} es un marco de trabajo relativamente estructurado y con roles específicos 
dentro de la metodología Agile (roles principales: \emph{Product Owner}, \emph{Scrum Master} y desarrollador) . Se 
puede utilizar tanto para la gestión de proyectos como para el desarrollo de productos, especialmente 
en el despliegue de \emph{software}. 

Con \emph{Scrum} los proyectos se dividen en iteraciones cortas llamadas \emph{sprints}. Al final de cada 
\emph{sprint} se debe presentar un producto mínimo viable y evaluar lo que se ha hecho bien y lo 
que se puede mejorar. 

Se ha optado por esta metodología, frente a otras como \emph{Waterfall} \citep{wiki:waterfall} , porque ofrece una alta 
adaptabilidad y genera entrega temprana de valor, con productos viables y valorables por el usuario 
final desde las primeras fases. 

\subsection{\emph{Test-Driven Development} (TDD)}\label{test_driven_development_tdd}

TDD \citep{wiki:TDD} es una metodología de desarrollo de software que se enfoca en escribir una batería 
de tests automatizados antes de iniciar la implementación del código fuente del propio software. Posteriormente, 
se hace un proceso de refactorización para mejorar o solucionar los defectos encontrados. 

Mis conocimientos previos de \emph{Django} y \emph{SQLite} no me han permitido utilizar de forma integral 
esta metodología, pero sí que se ha seguido en diferentes etapas del desarrollo, mejorando notablemente la 
calidad del código final. 

\subsection{\emph{Behavior-Driven Development} (BDD)}\label{behavior_driven_development_bdd}

BDD \citep{wiki:BDD} es una metodología que se basa en el comportamiento del software y me ha resultado útil 
en aquellas fases del proyecto en las que no tenía una idea preconcebida del cómo trabajar con \emph{Django} 
pero sí que conocía el resultado final esperado. 

La ventaja de este enfoque es que las pruebas se escriben en un lenguaje natural y es sencillo extrapolarlas a 
un gestor de tareas con un sistema Kanban. 

\subsection{\emph{Kanban}}\label{kanban}

Kanban \citep{wiki:Kanban} es un método visual de gestión de proyectos a través de la utilización de un tablero, 
en el que se disponen una serie de tarjetas con las tareas pendientes, en curso o finalizadas. Esto permite crear 
un flujo de trabajo que prioriza aquellas tareas más urgentes o que aportan antes valor a un producto.  



\section{Patrones de diseño}\label{patrones_diseno}

\subsection{\emph{Model-View-Template} (MVT)}\label{model_view_template}

Es el patrón de diseño de \emph{Django}, Modelo-Vista-Plantilla \citep{online:django_MVT_1,online:django_MVT_2}, que 
es similar al Modelo-Vista-Controlador (MVC) \citep{wiki:modelo_MVC}. En \emph{Django}, el Modelo representa la 
estructura de los datos, la Vista maneja la lógica de la aplicación (el controlador en MVC) y la Plantilla se encarga 
de la presentación de los datos (la vista en MVC). 

Una de las ventajas de \emph{Django} es que este modelo está plenamente integrado y promueve un acoplamiento 
débil, lo que facilita el mantenimiento y la escalabilidad de una aplicación. 

\imagen{img_16_django_MVT.png}{Patrón MVT. Fuente: realización propia}{1}



\section{Control de versiones}\label{control_versiones}

\begin{itemize}
\tightlist
\item  
Herramientas consideradas: Git \citep{online:git}, Apache Subversion \citep{online:apache_subversion} 
y Mercurial \citep{online:mercurial}.
\item
  Herramienta elegida: Git.
\end{itemize}

Git y Mercurial son sistemas de control de versiones distribuidos (DVCS),
mientras que Subversion - o SVN - es centralizado (VCS). 

Una de las ventajas de Git es que permite a cada desarrollador tener una copia en local del repositorio 
completo y, aunque es menos eficiente para proyectos muy grandes, es más sencillo de utilizar para proyectos 
pequeños. Además, el sistema de ramificación de Git es más intuitivo y facilita la tarea de los desarrolladores. 


\section{Alojamiento del repositorio}\label{alojamiento_repositorio}

\begin{itemize}
\tightlist
\item
  Herramientas consideradas: GitHub \citep{online:github}, GitLab \citep{online:gitlab} y Gitea \citep{online:gitea}.
\item
  Herramienta elegida: GitHub. 
\end{itemize}

Me he decantado por GitHub porque ya lo conocía, porque se utiliza en 
algunas asignaturas del Grado de Ingeniería Informática y porque es muy 
popular, lo que facilita la resolución de problemas gracias a su mayor 
comunidad. 

GitHub puede ofrecer menor control sobre proyectos grandes - Gitea y GitLab 
permiten auto hospedaje con la configuración que más nos interese -, pero en 
proyectos medios o pequeños es una herramienta práctica y sencilla de 
utilizar, con diferentes integraciones y que facilita el uso de flujos 
de trabajo CI/CD. 


\section{Gestión del proyecto}\label{gestion_del_proyecto}

\begin{itemize}
\tightlist
\item
  Herramientas consideradas: Zube \citep{online:zube}, ZenHub \citep{online:zenhub}, Trello \citep{online:trello} y Jira \citep{online:jira}. 
\item
  Herramienta elegida: Zube.
\end{itemize}

Zube es una plataforma de gestión de proyectos que se integra muy bien con GitHub. Además,
permite la sincronización en tiempo real con el repositorio de referencia que se esté 
utilizando y ofrece una interfaz fácil de utilizar con posibilidad de seguimiento
a través de \emph{burndonws} , \emph{burnups} y \emph{throughput} del equipo de desarrollo 
o de los desarrolladores de forma individual. 

Frente a las alternativas valoradas, Zube ha sido la más intuitiva,
permitiendo hacer seguimiento y planificación del proyecto en pocos pasos. 


\section{Comunicación}\label{comunicacion}

\begin{itemize}
\tightlist
\item
  Herramientas consideradas: email, GitHub y Microsoft Teams \citep{online:ms_teams}.
\item
  Herramientas elegidas: todas las anteriores. 
\end{itemize}

La comunicación en tiempo real, con llamadas o vídeo llamadas a través de Teams, 
 aporta soluciones rápidas por el continuo flujo de preguntas-respuestas. Pero no 
 siempre se pueden utilizar estos medios y es preferible hacer uso de email 
 o de \emph{requests} de \emph{GitHub}. Además, recientemente, se ha dado la posibilidad
 de integrar MS Teams con GitHub \citep{online:integrar_teams_github} para enviar notificaciones 
 a un grupo de trabajo. 


\section{Entorno de desarrollo integrado (IDE)}\label{ide}

\begin{itemize}
\tightlist
\item
  Herramientas consideradas: Spyder IDE \citep{online:spyder}, Visual Studio Code \citep{online:vs_code}.
\item
  Herramienta elegida: Visual Studio Code. 
\end{itemize}

A pesar de que ambos entornos tienen plugins de alta calidad, VS Code ofrece mayor 
personalización. Además, VS Code es integrable con \emph{GitHub} de forma sencilla y
ofrece aplicaciones de terceros que facilitan tanto la implementación de código como
las labores de testeo y control de calidad. 

VS Code se ha utilizado en este trabajo para desarrollo de \emph{Django}, como editor 
\emph{CSS} y \emph{HTML}, para \emph{JavaScript} y para \emph{Markdown}, así como medio de integracción con \emph{GitHub}, entre otros. 


\section{Documentación de la memoria}\label{editor_texto}

\begin{itemize}
\tightlist
\item
  Herramientas consideradas: Texmaker \citep{online:texmaker} y TeXstudio \citep{online:texstudio}.
\item
  Herramienta elegida: Texmaker. 
\end{itemize}

\emph{Texmaker} es un editor de texto gratuito, multiplataforma y que integra diversas
herramientas necesarias para desarrollar documentos \LaTeX. \emph{Texmaker} incluye soporte 
\emph{Unicode}, corrección ortográfica, auto-completado y un visor de PDF incorporado que es
realmente útil. 

Adicionalmente, cabe destacar que la integración de \emph{Texmaker} con la distribución 
de \TeX / \LaTeX \emph{MikTex} \citep{wiki:miktex} es menos problemática que con \emph{TeXstudio}. 


\section{Documentación del código}\label{editor_texto}

\begin{itemize}
\tightlist
\item
  Herramientas consideradas: Sphinx \citep{online:sphinx}, Read the Docs \citep{online:readthedocs} y pdoc \citep{online:pdoc}.
\item
  Herramientas elegidas: Sphinx y Read the Docs. 
\end{itemize}

\emph{Sphinx} es la herramienta más extendida en la comunidad \emph{Python} para documentar código,
es compatible con varios formatos y estilos de \emph{docstrings} - \emph{PyDoc}, \emph{Google} o \emph{Numpy} entre otros - y, además, puede generar documentación de manera automática a partir de los \emph{docstrings}. 

En este trabajo, se ha escogido el formato de \emph{Numpy} para la documentación de código y el estilo de \emph{Read The Docs} para las plantillas de la documentación HTML.

La documentación del código puede ser consultada en \href{https://fat.readthedocs.io/es/latest/index.html}{fat.readthedocs.io} o en \href{https://fat.readthedocs.io/es/latest/}{fat.rtfd.io}


\section{Integración y despliegue continuos (CI/CD)}\label{ci_cd}

\begin{itemize}
\tightlist
\item
  Herramientas consideradas: GitHub actions \citep{online:github_actions}, Jenkins \citep{online:jenkins} y CircleCI \citep{online:circle_ci}.
\item
  Herramienta elegida: GitHub actions.
\end{itemize}

GitHub actions es una plataforma de CI/CD que permite automatizar el proceso de compilación,
pruebas y despliegue de software. En este trabajo, GitHub actions se ha utilizado para 
tetear y comprobar la calidad del código a través de flujo de trabajo que se activan con 
cada evento de \emph{push} al \emph{branch} \emph{main} del repositorio de GitHub. 


\section{Calidad y consistencia de código}\label{calidad_codigo}

\begin{itemize}
\tightlist
\item
  Herramientas consideradas: Pylint \citep{online:pylint} y Flake8 \citep{online:flake8}.
\item
  Herramienta elegida: Pylint.
\end{itemize}

\emph{Pylint} es una herramienta de análisis de código estático para \emph{Python}, 
diseñada para detectar errores y mejorar la calidad del código. Este analizaor de código se
utilizar para verificar sintaxis, semántica y obliga a seguir las convenciones de estilo
de \emph{Python}. 

Se ha escogido \emph{Pylint} frente a \emph{Flake8} porque, adicionalmente, permite medir la calidad del código en términos de complejidad y legibilidad, lo que favorece un mantenimiento posterior. Además, con \emph{Pylint} podemos hacer informes que señalan todos los fallos, 
- aumentando la productividad - y es posible integrarlo con \emph{GitHub actions}, como se ha hecho en este proyecto.


\section{Cobertura de código}\label{cobertura_codigo}

\begin{itemize}
\tightlist
\item
  Herramientas consideradas: Coverage  \citep{online:coverage} y Pytest-cov \citep{online:pytest_cov}.
\item
  Herramienta elegida: Coverage.
\end{itemize}

\emph{Coverage} es una herramienta que permite medir la cobertura de código en \emph{Python}. 
Tiene la ventaja de que está bien integrada con proyectos de \emph{Django} y permite reconocer
los \emph{django.test.TestCase}. Además, se puede incorporar a \emph{GitHub actions}, tal y como 
se ha realizado en este proyecto, a través de un documento \emph{YAML}.

Uno de los aspectos relevantes de \emph{coverage} es que, con pocos comandos, permite generar
un informe HTML muy intuitivo que guía al desarrollador hacia los fallos detectados. 


\section{Framework web}\label{framework_web}

\begin{itemize}
\tightlist
\item
  Herramientas consideradas: Django \citep{online:django} y Flask \citep{online:flask}.
\item
  Herramienta elegida: Django.
\end{itemize}

\emph{Django} es un \emph{framework web} muy completo que incluye diversas características por defecto. También adopta un elevado nivel de seguridad y es altamente escalable. Es menos ligero que
\emph{Flask} pero, a cambio, ofrece mayor nivel de personalización y control sobre el sitio web, así como una mejor estructuración general de un proyecto.  


\section{Sistema gestor de bases de datos}\label{sgbd}

\begin{itemize}
\tightlist
\item
  Herramientas consideradas: SQLite \citep{online:sqlite} y PotgreSQL \citep{online:postgresql}.
\item
  Herramienta elegida: SQLite.
\end{itemize}

\emph{SQLite} es una librería de código escrita en lenguaje C, que implementa un motor de bases de datos pequeño y rápido. Se califican a sí mismos como un sistema gestor de bases de datos ligero y multiplataforma. Tiene la ventaja de estar muy extendido y utilizan un único archivo en el sistema de almacenamiento, lo que favorece su distribución y uso. 

Por su parte, \emph{PostgreSQL} tiene opciones más avanzadas que \emph{SQLite} y está pensado
 para soportar alta concurrencia y bases de datos grandes. Pero \emph{SQLite} está
 perfectamente integrado con \emph{Django} y no requiere de configuración adicional como sí requeriría \emph{PostgreSQL}. Además, \emph{SQLite} es suficiente para las expectativas de 
 este trabajo - la migración a \emph{PostgreSQL} sería recomendable en caso de escalar el proyecto -.


\section{Bibliotecas y librerías relevantes}\label{librerias_relevantes}

En este apartado se indican las bibliotecas y librerías más relevantes dentro del proyecto. Hay otras muchas que forman parte del conjunto de dependencias y que se pueden consultar en el archivo de \emph{requirements}.

\subsection{Pandas}\label{pandas}

\emph{Pandas} \citep{online:pandas} es una biblioteca de código abierto para \emph{Python} especializada en análisis de datos. Es útil para cargar datos desde diversas fuentes - como una base de datos o una API -, permite tratar los datos y transformarlos o incluso crear visualizaciones. 

\subsection{Plotly}\label{plotly}

\emph{Plotly} \citep{online:plotly} es una biblioteca de código abierto que se utiliza para crear visualizaciones de datos interactivas en \emph{Python}. Permite crear gráficos de barras o líneas, entre otros, y permite dar una alta personalización a la información que recibe el usuario final. 

\subsection{Matplotlib}\label{matplotlib}

\emph{Matplotlib} \citep{online:matplotlib} es una librería para crear visualizaciones estáticas, animadas e interactivas en \emph{Python}. Es una herramienta de código abierto, multiplataforma y está orientada a objetos. 

La curva de aprendizaje de \emph{Matplotlib} puede ser más compleja que en otras herramientas similares, pero ofrece mayor control sobre los datos y la forma de representarlos, especialmente cuando se utiliza para gráficos estadísticos. 

\subsection{yFinance}\label{yfinance}

\emph{yFinance} \citep{online:yfinance} es una biblioteca de código abierto para \emph{Python} que permite el acceso y procesado de datos financieros. Permite la recuperación de datos históricos y en tiempo real de cotizaciones de acciones, índices bursátiles, divisas, criptomonedas y otros instrumentos financieros. En este trabajo se utiliza para recuperar datos de valores cotizados y sus divisas de referencia - siempre con precios de cierre de mercado -. 

Entre las ventajas que ofrece es que su uso está bastante extendido y tiene una comunidad que facilita la resolución de problemas. Además, es fácil de utilizar y dispone de múltiples ejemplos en su documentación que permiten que la curva de aprendizaje sea progresiva. 

\subsection{News API}\label{news_api}

\emph{News API} \citep{online:news_api} es una biblioteca de código abierto, de \emph{Python}, que facilita el acceso y
la integración de noticias en una aplicación. Es un servicio web que proporciona una amplia variedad de artículos y noticias actualizadas, ordenadas por diferentes categorías, países y fuentes de información. 

\subsection{Feedparser}\label{feedparser}

\emph{Feedparser} \citep{online:feedparser} es una librería que permite analizar y procesar \emph{feeds RSS} y \emph{Atom}. En este trabajo se utiliza para obtener información relativa a índices bursátiles desde enlaces \emph{RSS}. Los \emph{feeds} de los datos se proveen con archivos en formato \emph{XML} y proceden de fuentes relacionadas con mercados financieros nacionales e internacionales (en todos los casos se utilizan fuentes conocidas y contrastadas). 

\subsection{NetworkX}\label{networkx}

\emph{NetworkX} \citep{online:networkx} es una biblioteca que se utiliza para el estudio y análisis de redes complejas. Entre sus funciones principales se pueden encontrar las de crear, manipular y analizar grafos. Estos grafos son estructuras matemáticas que modelan relaciones entre objetos y, en el caso de  este trabajo, se utiliza para visualizar las mayores correlaciones - positiva y negativa - entre las cotizaciones de todos los valores de los índices estudiados. 

\subsection{Statsmodels}\label{statsmodels}

\emph{Statsmodels} \citep{online:statsmodels} es una biblioteca de \emph{Python} que se utiliza para el análisis y modelado estadístico de datos. Permite explorar, estimar y evaluar modelos estadísticos complejos; y ofrece herramientas para el análisis de series temporales. En este proyecto se utiliza para configurar y aplicar modelos ARIMA. 

\subsection{Scikit-learn}\label{scikit-learn}

\emph{Scikit-learn} \citep{online:scikit_learn} es una bilioteca de código abierto para el aprendizaje automático en \emph{Python}. Se utiliza frecuentemente para clasificación de datos, regresión, agrupación y reducción de dimensionalidad. Sin embargo, en este trabajo se utiliza sólo para calcular el \emph{MSE} (Mean Squared Error) entre datos de test y predicciones de modelos y para normalizar datos en una escala concreta.  


\subsection{Scipy}\label{scipy}

\emph{Scipy} \citep{2020SciPy-NMeth} SciPy es una biblioteca de código abierto de \emph{Python} que se utiliza comúnmente en cálculo científico y ciencia de datos. Proporciona módulos para resolver problemas matemáticos, científicos, de ingeniería y técnicos. En este trabajo se utiliza para resolver problemas de programación cuadrática y lineal. 

\subsection{Keras}\label{keras}

\emph{Keras} \citep{online:keras} es una biblioteca de código abierto para aprendizaje profundo escrita en \emph{Python} - en este proyecto se ejecuta sobre \emph{TensorFlow} \citep{online:tensorflow} -. \emph{Keras} sirve para crear y entrenar redes neuronales y para experimentar con diferentes arquitecturas de estas redes. Su modularidad permite crear redes muy complejas y, además, es muy eficiente tanto en entrenamiento como en inferencia. En este trabajo se utiliza para crear redes \emph{LSTM} y realizar análisis de series temporales. 


\section{Desarrollo web}\label{desarrollo_web}

\subsection{HTML}\label{html}

\emph{HTML} \citep{wiki:html} es el lenguaje de marcado de hipertexto estándar para crear páginas web. Es un lenguaje que utiliza etiquetas para definir la esrtructura y el contenido de una página web. 

\subsection{CSS}\label{css}

\emph{CSS} \citep{wiki:css} es un lenguaje de hojas de estilo que se utiliza para dar un aspecto y diseño agradables a una página web. Se utiliza junto con \emph{HTML}.

\subsection{Bootstrap}\label{bootstrap}

\emph{Bootstrap} \citep{online:bootstrap} es un \emph{framewrok} de código abierto para el desarrollo web \emph{front-end}. Proporciona un conjunto de herramientas y componentes predefinidos que permiten a los desarrolladores crear plantillas e interfaces atractivas y responsivas. 

\subsection{JavaScript}\label{javascript}

\emph{JavaScript} \citep{wiki:javascript} es un lenguaje de programación interpretado, orientado a objetos y débilmente tipado. En este trabajo se utiliza para desarrollo web \emph{front-end} para agregar 
interactividad y dinamismo a la página web. 


\section{Otras herramientas}\label{otras_herramientas}

\subsection{python-dotenv}\label{python-dotenv}

\emph{python-dotenv} \citep{online:dotenv} es una biblioteca que permite gestionar variables de entorno para aplicaciones \emph{Python}. Se puede utilizar, entre otros, para securizar las \emph{API keys} de \emph{Django} y \emph{News API}. 

\subsection{Draw.io}\label{draw_io}

\emph{Draw.io} \citep{online:drawio} es una herramienta de diseño de diagramas y esquemas que incluye una amplia variedad de formas predefinidas. Permite exportar el resultado en varios formatos, lo que facilita la integración con diferentes editores de texto. 

\subsection{Mendeley}\label{mendeley}

\emph{Mendeley} \citep{online:mendeley} es una herramienta de gestión de referecnias bibliográficas y colaboración académica. Entre sus características cabe destacar la capacidad de organizar las referencias y exportarlas a un archivo que se puede utilizar desde \LaTeX. 
